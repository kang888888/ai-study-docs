{
  "title": "CNN (Convolutional Neural Network) å·ç§¯ç¥ç»ç½‘ç»œ",
  "subtitle": "ä¸“é—¨ç”¨äºå¤„ç†å›¾åƒæ•°æ®çš„ç¥ç»ç½‘ç»œ",
  "content": [
    {
      "type": "section",
      "title": "ğŸ“– æ ¸å¿ƒæ¦‚å¿µ",
      "content": [
        {
          "type": "desc-box",
          "content": [
            "ä¸“é—¨ç”¨äºå¤„ç†å…·æœ‰ç½‘æ ¼ç»“æ„çš„æ•°æ®ï¼ˆå¦‚å›¾åƒã€è§†é¢‘ï¼‰ã€‚é€šè¿‡å·ç§¯å±‚æå–å±€éƒ¨ç‰¹å¾ï¼Œæ± åŒ–å±‚é™ä½ç»´åº¦ï¼Œæ˜¯è®¡ç®—æœºè§†è§‰é¢†åŸŸçš„åŸºçŸ³ã€‚"
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸŒŸ æ ¸å¿ƒç‰¹ç‚¹",
      "content": [
        {
          "type": "features",
          "items": [
            "å±€éƒ¨è¿æ¥ï¼šæ¯ä¸ªç¥ç»å…ƒåªä¸å±€éƒ¨åŒºåŸŸè¿æ¥ï¼Œå¤§å¹…å‡å°‘å‚æ•°",
            "æƒå€¼å…±äº«ï¼šåŒä¸€å·ç§¯æ ¸åœ¨æ•´ä¸ªè¾“å…¥ä¸Šå…±äº«å‚æ•°",
            "å¹³ç§»ä¸å˜æ€§ï¼šå¯¹å›¾åƒçš„å¹³ç§»å…·æœ‰é²æ£’æ€§",
            "å±‚æ¬¡åŒ–ç‰¹å¾æå–ï¼šæµ…å±‚æå–è¾¹ç¼˜ï¼Œæ·±å±‚æå–è¯­ä¹‰ç‰¹å¾",
            "æ± åŒ–é™ç»´ï¼šé€šè¿‡Max Poolingæˆ–Average Poolingé™ä½ç‰¹å¾å›¾å°ºå¯¸"
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "âš™ï¸ å…³é”®æŠ€æœ¯",
      "content": [
        {
          "type": "tech-box",
          "content": "å·ç§¯æ“ä½œã€æ± åŒ–æ“ä½œã€æ‰¹é‡å½’ä¸€åŒ–ï¼ˆBatch Normalizationï¼‰ã€Dropoutæ­£åˆ™åŒ–"
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸš€ åº”ç”¨åœºæ™¯",
      "content": [
        {
          "type": "app-box",
          "content": "å›¾åƒåˆ†ç±»ï¼ˆImageNetï¼‰ã€ç›®æ ‡æ£€æµ‹ã€å›¾åƒåˆ†å‰²ã€äººè„¸è¯†åˆ«ã€åŒ»å­¦å½±åƒåˆ†æ"
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ“Š æ¶æ„å›¾è§£",
      "content": [
        {
          "type": "diagram-gallery",
          "images": [
            {
              "type": "svg-d3",
              "component": "CNNDiagram",
              "caption": "CNNæ¶æ„å›¾",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "CNNæ¶æ„å›¾"
              }
            },
            {
              "type": "svg-d3",
              "component": "CNNDiagram",
              "caption": "å·ç§¯æ“ä½œ",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "convolution",
                "title": "å·ç§¯æ“ä½œ"
              }
            },
            {
              "type": "svg-d3",
              "component": "CNNDiagram",
              "caption": "æ± åŒ–æ“ä½œ",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "pooling",
                "title": "æ± åŒ–æ“ä½œ"
              }
            }
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ“ æ•°å­¦åŸç†",
      "content": [
        {
          "type": "math-box",
          "title": "å·ç§¯æ“ä½œ",
          "formulas": [
            {
              "text": "äºŒç»´ç¦»æ•£å·ç§¯å…¬å¼ï¼š"
            },
            {
              "display": "(I * K)(i, j) = \\sum_{m} \\sum_{n} I(i-m, j-n) \\cdot K(m, n)"
            },
            {
              "text": "å…¶ä¸­ $I$ æ˜¯è¾“å…¥ç‰¹å¾å›¾ï¼Œ$K$ æ˜¯å·ç§¯æ ¸ï¼ˆæ»¤æ³¢å™¨ï¼‰",
              "inline": "I"
            }
          ]
        },
        {
          "type": "math-box",
          "title": "è¾“å‡ºå°ºå¯¸è®¡ç®—",
          "formulas": [
            {
              "text": "å·ç§¯åè¾“å‡ºå°ºå¯¸ï¼š"
            },
            {
              "display": "H_{out} = \\frac{H_{in} + 2P - K}{S} + 1"
            },
            {
              "display": "W_{out} = \\frac{W_{in} + 2P - K}{S} + 1"
            },
            {
              "text": "å…¶ä¸­ï¼š"
            }
          ]
        },
        {
          "type": "math-box",
          "title": "æ± åŒ–æ“ä½œ",
          "formulas": [
            {
              "text": "æœ€å¤§æ± åŒ–ï¼ˆMax Poolingï¼‰ï¼š"
            },
            {
              "display": "y_{i,j} = \\max_{(m,n) \\in R_{i,j}} x_{m,n}"
            },
            {
              "text": "å¹³å‡æ± åŒ–ï¼ˆAverage Poolingï¼‰ï¼š"
            },
            {
              "display": "y_{i,j} = \\frac{1}{|R_{i,j}|} \\sum_{(m,n) \\in R_{i,j}} x_{m,n}"
            },
            {
              "text": "å…¶ä¸­ $R_{i,j}$ æ˜¯æ± åŒ–çª—å£åŒºåŸŸ",
              "inline": "R_{i,j}"
            }
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ’» Python ä»£ç ç¤ºä¾‹",
      "content": [
        {
          "type": "code-box",
          "title": "ä½¿ç”¨ PyTorch å®ç° CNN",
          "language": "python",
          "code": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass SimpleCNN(nn.Module):\n    \"\"\"ç®€å•çš„CNNå®ç°ï¼ˆç”¨äºå›¾åƒåˆ†ç±»ï¼‰\"\"\"\n    def __init__(self, num_classes=10):\n        super(SimpleCNN, self).__init__()\n        \n        # ç¬¬ä¸€ä¸ªå·ç§¯å—\n        self.conv1 = nn.Conv2d(in_channels=3, out_channels=32, kernel_size=3, padding=1)\n        self.bn1 = nn.BatchNorm2d(32)\n        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)\n        \n        # ç¬¬äºŒä¸ªå·ç§¯å—\n        self.conv2 = nn.Conv2d(in_channels=32, out_channels=64, kernel_size=3, padding=1)\n        self.bn2 = nn.BatchNorm2d(64)\n        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)\n        \n        # ç¬¬ä¸‰ä¸ªå·ç§¯å—\n        self.conv3 = nn.Conv2d(in_channels=64, out_channels=128, kernel_size=3, padding=1)\n        self.bn3 = nn.BatchNorm2d(128)\n        self.pool3 = nn.MaxPool2d(kernel_size=2, stride=2)\n        \n        # å…¨è¿æ¥å±‚\n        self.fc1 = nn.Linear(128 * 4 * 4, 512)\n        self.dropout = nn.Dropout(0.5)\n        self.fc2 = nn.Linear(512, num_classes)\n    \n    def forward(self, x):\n        # å·ç§¯å—1: 32x32 -> 16x16\n        x = F.relu(self.bn1(self.conv1(x)))\n        x = self.pool1(x)\n        \n        # å·ç§¯å—2: 16x16 -> 8x8\n        x = F.relu(self.bn2(self.conv2(x)))\n        x = self.pool2(x)\n        \n        # å·ç§¯å—3: 8x8 -> 4x4\n        x = F.relu(self.bn3(self.conv3(x)))\n        x = self.pool3(x)\n        \n        # å±•å¹³\n        x = x.view(x.size(0), -1)\n        \n        # å…¨è¿æ¥å±‚\n        x = F.relu(self.fc1(x))\n        x = self.dropout(x)\n        x = self.fc2(x)\n        \n        return x\n\n# ä½¿ç”¨ç¤ºä¾‹\nif __name__ == \"__main__\":\n    # åˆ›å»ºæ¨¡å‹\n    model = SimpleCNN(num_classes=10)\n    \n    # æ¨¡æ‹Ÿè¾“å…¥ (batch_size=4, channels=3, height=32, width=32)\n    x = torch.randn(4, 3, 32, 32)\n    \n    # å‰å‘ä¼ æ’­\n    output = model(x)\n    print(f\"è¾“å‡ºå½¢çŠ¶: {output.shape}\")  # [4, 10]\n    \n    # è®¡ç®—å‚æ•°é‡\n    total_params = sum(p.numel() for p in model.parameters())\n    print(f\"æ€»å‚æ•°é‡: {total_params:,}\")"
        },
        {
          "type": "code-box",
          "title": "ä½¿ç”¨ NumPy æ‰‹åŠ¨å®ç°å·ç§¯æ“ä½œ",
          "language": "python",
          "code": "import numpy as np\n\ndef conv2d(input_img, kernel, stride=1, padding=0):\n    \"\"\"\n    æ‰‹åŠ¨å®ç°2Då·ç§¯æ“ä½œ\n    \n    å‚æ•°:\n        input_img: è¾“å…¥å›¾åƒ (H, W) æˆ– (C, H, W)\n        kernel: å·ç§¯æ ¸ (K, K) æˆ– (C, K, K)\n        stride: æ­¥é•¿\n        padding: å¡«å……\n    \"\"\"\n    # å¤„ç†è¾“å…¥ç»´åº¦\n    if input_img.ndim == 2:\n        input_img = input_img[np.newaxis, :, :]\n    \n    if kernel.ndim == 2:\n        kernel = kernel[np.newaxis, :, :]\n    \n    C, H, W = input_img.shape\n    K = kernel.shape[-1]\n    \n    # æ·»åŠ padding\n    if padding > 0:\n        input_img = np.pad(input_img, ((0, 0), (padding, padding), (padding, padding)), mode='constant')\n    \n    # è®¡ç®—è¾“å‡ºå°ºå¯¸\n    out_h = (H + 2 * padding - K) // stride + 1\n    out_w = (W + 2 * padding - K) // stride + 1\n    \n    # åˆå§‹åŒ–è¾“å‡º\n    output = np.zeros((C, out_h, out_w))\n    \n    # æ‰§è¡Œå·ç§¯\n    for c in range(C):\n        for i in range(0, out_h):\n            for j in range(0, out_w):\n                h_start = i * stride\n                h_end = h_start + K\n                w_start = j * stride\n                w_end = w_start + K\n                \n                output[c, i, j] = np.sum(\n                    input_img[c, h_start:h_end, w_start:w_end] * kernel[c]\n                )\n    \n    return output.squeeze() if output.shape[0] == 1 else output\n\ndef max_pooling(input_img, pool_size=2, stride=2):\n    \"\"\"æœ€å¤§æ± åŒ–æ“ä½œ\"\"\"\n    if input_img.ndim == 2:\n        input_img = input_img[np.newaxis, :, :]\n    \n    C, H, W = input_img.shape\n    out_h = (H - pool_size) // stride + 1\n    out_w = (W - pool_size) // stride + 1\n    \n    output = np.zeros((C, out_h, out_w))\n    \n    for c in range(C):\n        for i in range(out_h):\n            for j in range(out_w):\n                h_start = i * stride\n                h_end = h_start + pool_size\n                w_start = j * stride\n                w_end = w_start + pool_size\n                \n                output[c, i, j] = np.max(\n                    input_img[c, h_start:h_end, w_start:w_end]\n                )\n    \n    return output.squeeze() if output.shape[0] == 1 else output\n\n# ä½¿ç”¨ç¤ºä¾‹\nif __name__ == \"__main__\":\n    # åˆ›å»ºæµ‹è¯•å›¾åƒ (3é€šé“, 8x8)\n    img = np.random.randn(3, 8, 8)\n    \n    # åˆ›å»ºå·ç§¯æ ¸ (3x3)\n    kernel = np.ones((3, 3, 3)) * 0.1\n    \n    # æ‰§è¡Œå·ç§¯\n    conv_output = conv2d(img, kernel, stride=1, padding=1)\n    print(f\"å·ç§¯è¾“å‡ºå½¢çŠ¶: {conv_output.shape}\")\n    \n    # æ‰§è¡Œæ± åŒ–\n    pooled_output = max_pooling(conv_output, pool_size=2, stride=2)\n    print(f\"æ± åŒ–è¾“å‡ºå½¢çŠ¶: {pooled_output.shape}\")"
        }
      ]
    }
  ]
}