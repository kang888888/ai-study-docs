{
  "title": "ResNet (Residual Network) æ®‹å·®ç½‘ç»œ",
  "subtitle": "è§£å†³æ¢¯åº¦æ¶ˆå¤±é—®é¢˜çš„æ·±åº¦ç½‘ç»œæ¶æ„",
  "content": [
    {
      "type": "section",
      "title": "ğŸ“– æ ¸å¿ƒæ¦‚å¿µ",
      "content": [
        {
          "type": "desc-box",
          "content": [
            "é€šè¿‡å¼•å…¥æ®‹å·®è¿æ¥ï¼ˆSkip Connection / Shortcutï¼‰ï¼Œå…è®¸æ¢¯åº¦ç›´æ¥æµå‘æµ…å±‚ï¼Œè§£å†³äº†æ·±å±‚ç½‘ç»œï¼ˆ100+å±‚ï¼‰éš¾ä»¥è®­ç»ƒçš„æ¢¯åº¦æ¶ˆå¤±/çˆ†ç‚¸é—®é¢˜ã€‚"
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸŒŸ æ ¸å¿ƒç‰¹ç‚¹",
      "content": [
        {
          "type": "features",
          "items": [
            "æ®‹å·®å­¦ä¹ ï¼šå­¦ä¹  F(x) = H(x) - xï¼Œè€Œéç›´æ¥å­¦ä¹  H(x)",
            "æ’ç­‰æ˜ å°„ï¼šé€šè¿‡è·³è·ƒè¿æ¥å®ç°æ¢¯åº¦çš„æ— æŸä¼ æ’­",
            "ææ·±ç½‘ç»œï¼šå¯ä»¥è®­ç»ƒ152å±‚ç”šè‡³æ›´æ·±çš„ç½‘ç»œ",
            "ç“¶é¢ˆç»“æ„ï¼šä½¿ç”¨1Ã—1å·ç§¯é™ç»´ï¼Œå‡å°‘è®¡ç®—é‡",
            "å¹¿æ³›åº”ç”¨ï¼šæˆä¸ºç°ä»£è§†è§‰æ¨¡å‹çš„æ ‡å‡†Backbone"
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "âš™ï¸ å…³é”®æŠ€æœ¯",
      "content": [
        {
          "type": "tech-box",
          "content": "æ®‹å·®å—ï¼ˆResidual Blockï¼‰ã€æ‰¹é‡å½’ä¸€åŒ–ã€æ’ç­‰æ˜ å°„ã€ç“¶é¢ˆè®¾è®¡"
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸš€ åº”ç”¨åœºæ™¯",
      "content": [
        {
          "type": "app-box",
          "content": "å›¾åƒåˆ†ç±»ã€ç›®æ ‡æ£€æµ‹çš„Backboneã€ç‰¹å¾æå–ã€è¿ç§»å­¦ä¹ "
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ“Š æ¶æ„å›¾è§£",
      "content": [
        {
          "type": "diagram-gallery",
          "images": [
            {
              "type": "svg-d3",
              "component": "ResNetDiagram",
              "caption": "ResNetæ®‹å·®å—",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "ResNetæ®‹å·®å—",
                "data": null
              }
            },
            {
              "type": "svg-d3",
              "component": "ResNetDiagram",
              "caption": "ResNetæ¶æ„å›¾",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "ResNetæ¶æ„å›¾",
                "data": null
              }
            },
            {
              "type": "svg-d3",
              "component": "ResNetDiagram",
              "caption": "ResNetæ¢¯åº¦æµåŠ¨",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "ResNetæ¢¯åº¦æµåŠ¨",
                "data": null
              }
            }
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ“ æ•°å­¦åŸç†",
      "content": [
        {
          "type": "math-box",
          "title": "æ®‹å·®å­¦ä¹ ",
          "formulas": [
            {
              "text": "ResNetçš„æ ¸å¿ƒæ€æƒ³æ˜¯å­¦ä¹ æ®‹å·®è€Œéç›´æ¥æ˜ å°„ï¼š"
            },
            {
              "display": "H(x) = F(x) + x"
            },
            {
              "text": "å…¶ä¸­ï¼š"
            },
            {
              "text": "å¦‚æœæœ€ä¼˜æ˜ å°„æ¥è¿‘æ’ç­‰æ˜ å°„ï¼Œå­¦ä¹ æ®‹å·® $F(x) \\approx 0$ æ¯”å­¦ä¹  $H(x) \\approx x$ æ›´å®¹æ˜“",
              "inline": "F(x) \\approx 0"
            }
          ]
        },
        {
          "type": "math-box",
          "title": "æ¢¯åº¦æµåŠ¨",
          "formulas": [
            {
              "text": "æ®‹å·®è¿æ¥ä½¿å¾—æ¢¯åº¦å¯ä»¥ç›´æ¥ä¼ æ’­ï¼š"
            },
            {
              "display": "\\frac{\\partial L}{\\partial x} = \\frac{\\partial L}{\\partial H(x)} \\cdot \\left(1 + \\frac{\\partial F(x)}{\\partial x}\\right)"
            },
            {
              "text": "å³ä½¿ $\\frac{\\partial F(x)}{\\partial x} \\approx 0$ï¼Œæ¢¯åº¦ä»å¯ä»¥é€šè¿‡æ’ç­‰é¡¹ $1$ ä¼ æ’­ï¼Œé¿å…äº†æ¢¯åº¦æ¶ˆå¤±",
              "inline": "\\frac{\\partial F(x)}{\\partial x} \\approx 0"
            }
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ’» Python ä»£ç ç¤ºä¾‹",
      "content": [
        {
          "type": "code-box",
          "title": "ä½¿ç”¨ PyTorch å®ç° ResNet æ®‹å·®å—",
          "language": "python",
          "code": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass ResidualBlock(nn.Module):\n    \"\"\"ResNet æ®‹å·®å—\"\"\"\n    def __init__(self, in_channels, out_channels, stride=1, downsample=None):\n        super(ResidualBlock, self).__init__()\n        self.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=3, \n                              stride=stride, padding=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(out_channels)\n        self.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=3,\n                              stride=1, padding=1, bias=False)\n        self.bn2 = nn.BatchNorm2d(out_channels)\n        self.downsample = downsample\n    \n    def forward(self, x):\n        identity = x\n        \n        out = self.conv1(x)\n        out = self.bn1(out)\n        out = F.relu(out)\n        \n        out = self.conv2(out)\n        out = self.bn2(out)\n        \n        if self.downsample is not None:\n            identity = self.downsample(x)\n        \n        out += identity  # æ®‹å·®è¿æ¥\n        out = F.relu(out)\n        \n        return out\n\nclass BottleneckBlock(nn.Module):\n    \"\"\"ResNet ç“¶é¢ˆå—ï¼ˆç”¨äºæ›´æ·±çš„ç½‘ç»œï¼‰\"\"\"\n    def __init__(self, in_channels, out_channels, stride=1, downsample=None):\n        super(BottleneckBlock, self).__init__()\n        expansion = 4\n        self.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=1, bias=False)\n        self.bn1 = nn.BatchNorm2d(out_channels)\n        self.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=3,\n                              stride=stride, padding=1, bias=False)\n        self.bn2 = nn.BatchNorm2d(out_channels)\n        self.conv3 = nn.Conv2d(out_channels, out_channels * expansion,\n                              kernel_size=1, bias=False)\n        self.bn3 = nn.BatchNorm2d(out_channels * expansion)\n        self.downsample = downsample\n    \n    def forward(self, x):\n        identity = x\n        \n        out = self.conv1(x)\n        out = self.bn1(out)\n        out = F.relu(out)\n        \n        out = self.conv2(out)\n        out = self.bn2(out)\n        out = F.relu(out)\n        \n        out = self.conv3(out)\n        out = self.bn3(out)\n        \n        if self.downsample is not None:\n            identity = self.downsample(x)\n        \n        out += identity\n        out = F.relu(out)\n        \n        return out\n\nclass ResNet(nn.Module):\n    \"\"\"ç®€å•çš„ ResNet å®ç°\"\"\"\n    def __init__(self, block, layers, num_classes=1000):\n        super(ResNet, self).__init__()\n        self.in_channels = 64\n        \n        self.conv1 = nn.Conv2d(3, 64, kernel_size=7, stride=2, padding=3, bias=False)\n        self.bn1 = nn.BatchNorm2d(64)\n        self.maxpool = nn.MaxPool2d(kernel_size=3, stride=2, padding=1)\n        \n        self.layer1 = self._make_layer(block, 64, layers[0])\n        self.layer2 = self._make_layer(block, 128, layers[1], stride=2)\n        self.layer3 = self._make_layer(block, 256, layers[2], stride=2)\n        self.layer4 = self._make_layer(block, 512, layers[3], stride=2)\n        \n        self.avgpool = nn.AdaptiveAvgPool2d((1, 1))\n        self.fc = nn.Linear(512, num_classes)\n    \n    def _make_layer(self, block, out_channels, blocks, stride=1):\n        downsample = None\n        if stride != 1 or self.in_channels != out_channels:\n            downsample = nn.Sequential(\n                nn.Conv2d(self.in_channels, out_channels, kernel_size=1,\n                         stride=stride, bias=False),\n                nn.BatchNorm2d(out_channels)\n            )\n        \n        layers = []\n        layers.append(block(self.in_channels, out_channels, stride, downsample))\n        self.in_channels = out_channels\n        \n        for _ in range(1, blocks):\n            layers.append(block(self.in_channels, out_channels))\n        \n        return nn.Sequential(*layers)\n    \n    def forward(self, x):\n        x = self.conv1(x)\n        x = self.bn1(x)\n        x = F.relu(x)\n        x = self.maxpool(x)\n        \n        x = self.layer1(x)\n        x = self.layer2(x)\n        x = self.layer3(x)\n        x = self.layer4(x)\n        \n        x = self.avgpool(x)\n        x = torch.flatten(x, 1)\n        x = self.fc(x)\n        \n        return x\n\n# ä½¿ç”¨ç¤ºä¾‹\nif __name__ == \"__main__\":\n    # ResNet-18: [2, 2, 2, 2] è¡¨ç¤ºæ¯ä¸ªlayeræœ‰2ä¸ªæ®‹å·®å—\n    model = ResNet(ResidualBlock, [2, 2, 2, 2], num_classes=1000)\n    \n    # æ¨¡æ‹Ÿè¾“å…¥\n    x = torch.randn(4, 3, 224, 224)\n    output = model(x)\n    print(f\"è¾“å‡ºå½¢çŠ¶: {output.shape}\")  # [4, 1000]"
        }
      ]
    }
  ]
}