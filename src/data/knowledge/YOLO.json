{
  "title": "YOLO (You Only Look Once) å•é˜¶æ®µç›®æ ‡æ£€æµ‹",
  "subtitle": "å®æ—¶ç›®æ ‡æ£€æµ‹ç®—æ³•",
  "content": [
    {
      "type": "section",
      "title": "ğŸ“– æ ¸å¿ƒæ¦‚å¿µ",
      "content": [
        {
          "type": "desc-box",
          "content": [
            "å°†ç›®æ ‡æ£€æµ‹è§†ä¸ºå›å½’é—®é¢˜ï¼Œåªéœ€ä¸€æ¬¡å‰å‘ä¼ æ’­å³å¯åŒæ—¶é¢„æµ‹æ‰€æœ‰è¾¹ç•Œæ¡†çš„ä½ç½®å’Œç±»åˆ«ã€‚ç›¸æ¯”ä¸¤é˜¶æ®µæ£€æµ‹å™¨ï¼ˆå¦‚Faster R-CNNï¼‰ï¼Œé€Ÿåº¦æå¿«ï¼Œé€‚åˆå®æ—¶åº”ç”¨ã€‚"
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸŒŸ æ ¸å¿ƒç‰¹ç‚¹",
      "content": [
        {
          "type": "features",
          "items": [
            "å•é˜¶æ®µæ£€æµ‹ï¼šä¸€æ¬¡å‰å‘ä¼ æ’­å®Œæˆæ£€æµ‹ï¼Œæ— éœ€Region Proposal",
            "é€Ÿåº¦æå¿«ï¼šYOLOv5å¯è¾¾140+ FPSï¼Œé€‚åˆå®æ—¶åœºæ™¯",
            "ç«¯åˆ°ç«¯è®­ç»ƒï¼šç›´æ¥ä¼˜åŒ–æ£€æµ‹æŸå¤±ï¼Œæ— éœ€å¤šé˜¶æ®µè®­ç»ƒ",
            "å…¨å±€ä¿¡æ¯ï¼šçœ‹åˆ°æ•´å¼ å›¾åƒï¼ŒèƒŒæ™¯è¯¯æ£€ç‡ä½",
            "ç‰ˆæœ¬è¿­ä»£ï¼šä»v1åˆ°v8/v9ï¼ŒæŒç»­ä¼˜åŒ–ç²¾åº¦å’Œé€Ÿåº¦"
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "âš™ï¸ å…³é”®æŠ€æœ¯",
      "content": [
        {
          "type": "tech-box",
          "content": "Anchor Boxã€éæå¤§å€¼æŠ‘åˆ¶ï¼ˆNMSï¼‰ã€å¤šå°ºåº¦é¢„æµ‹ã€æŸå¤±å‡½æ•°ï¼ˆIoU Lossï¼‰"
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸš€ åº”ç”¨åœºæ™¯",
      "content": [
        {
          "type": "app-box",
          "content": "å®æ—¶ç›®æ ‡æ£€æµ‹ã€è‡ªåŠ¨é©¾é©¶ã€æ™ºèƒ½ç›‘æ§ã€æ— äººæœºè§†è§‰ã€å·¥ä¸šè´¨æ£€"
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ“Š æ¶æ„å›¾è§£",
      "content": [
        {
          "type": "diagram-gallery",
          "images": [
            {
              "type": "svg-d3",
              "component": "YOLODiagram",
              "caption": "YOLOæ¶æ„å›¾",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "YOLOæ¶æ„å›¾"
              }
            },
            {
              "type": "svg-d3",
              "component": "YOLODiagram",
              "caption": "YOLOæ£€æµ‹æµç¨‹",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "YOLOæ£€æµ‹æµç¨‹"
              }
            },
            {
              "type": "svg-d3",
              "component": "YOLODiagram",
              "caption": "YOLOç‰ˆæœ¬æ¼”è¿›",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "YOLOç‰ˆæœ¬æ¼”è¿›"
              }
            },
            {
              "type": "svg-d3",
              "component": "YOLODiagram",
              "caption": "IoUè®¡ç®—",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "IoUè®¡ç®—"
              }
            }
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ“ æ•°å­¦åŸç†",
      "content": [
        {
          "type": "math-box",
          "title": "IoU (Intersection over Union)",
          "formulas": [
            {
              "text": "IoUç”¨äºè¡¡é‡é¢„æµ‹æ¡†å’ŒçœŸå®æ¡†çš„é‡å ç¨‹åº¦ï¼š"
            },
            {
              "display": "\\text{IoU} = \\frac{\\text{Area of Intersection}}{\\text{Area of Union}} = \\frac{A \\cap B}{A \\cup B}"
            },
            {
              "text": "IoUå€¼èŒƒå›´åœ¨ $[0, 1]$ï¼Œå€¼è¶Šå¤§è¡¨ç¤ºé‡å åº¦è¶Šé«˜",
              "inline": "[0, 1]"
            }
          ]
        },
        {
          "type": "math-box",
          "title": "YOLO æŸå¤±å‡½æ•°",
          "formulas": [
            {
              "text": "YOLOçš„æŸå¤±å‡½æ•°åŒ…å«å¤šä¸ªéƒ¨åˆ†ï¼š"
            },
            {
              "display": "L = \\lambda_{coord} \\sum_{i=0}^{S^2} \\sum_{j=0}^{B} \\mathbb{1}_{ij}^{obj} [(x_i - \\hat{x}_i)^2 + (y_i - \\hat{y}_i)^2]"
            },
            {
              "display": "+ \\lambda_{coord} \\sum_{i=0}^{S^2} \\sum_{j=0}^{B} \\mathbb{1}_{ij}^{obj} [(\\sqrt{w_i} - \\sqrt{\\hat{w}_i})^2 + (\\sqrt{h_i} - \\sqrt{\\hat{h}_i})^2]"
            },
            {
              "display": "+ \\sum_{i=0}^{S^2} \\sum_{j=0}^{B} \\mathbb{1}_{ij}^{obj} (C_i - \\hat{C}_i)^2 + \\lambda_{noobj} \\sum_{i=0}^{S^2} \\sum_{j=0}^{B} \\mathbb{1}_{ij}^{noobj} (C_i - \\hat{C}_i)^2"
            },
            {
              "display": "+ \\sum_{i=0}^{S^2} \\mathbb{1}_{i}^{obj} \\sum_{c \\in classes} (p_i(c) - \\hat{p}_i(c))^2"
            },
            {
              "text": "å…¶ä¸­ $S$ æ˜¯ç½‘æ ¼å¤§å°ï¼Œ$B$ æ˜¯æ¯ä¸ªç½‘æ ¼çš„è¾¹ç•Œæ¡†æ•°é‡",
              "inline": "S"
            }
          ]
        },
        {
          "type": "math-box",
          "title": "è¾¹ç•Œæ¡†åæ ‡è½¬æ¢",
          "formulas": [
            {
              "text": "ä»ç›¸å¯¹åæ ‡è½¬æ¢ä¸ºç»å¯¹åæ ‡ï¼š"
            },
            {
              "display": "b_x = \\sigma(t_x) + c_x"
            },
            {
              "display": "b_y = \\sigma(t_y) + c_y"
            },
            {
              "display": "b_w = p_w e^{t_w}"
            },
            {
              "display": "b_h = p_h e^{t_h}"
            },
            {
              "text": "å…¶ä¸­ $(c_x, c_y)$ æ˜¯ç½‘æ ¼å·¦ä¸Šè§’åæ ‡ï¼Œ$(p_w, p_h)$ æ˜¯anchorå°ºå¯¸",
              "inline": "(c_x, c_y)"
            }
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ’» Python ä»£ç ç¤ºä¾‹",
      "content": [
        {
          "type": "code-box",
          "title": "ä½¿ç”¨ PyTorch å®ç° YOLO æ ¸å¿ƒç»„ä»¶",
          "language": "python",
          "code": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport numpy as np\n\ndef calculate_iou(box1, box2):\n    \"\"\"è®¡ç®—ä¸¤ä¸ªè¾¹ç•Œæ¡†çš„IoU\"\"\"\n    # boxæ ¼å¼: [x1, y1, x2, y2]\n    x1 = max(box1[0], box2[0])\n    y1 = max(box1[1], box2[1])\n    x2 = min(box1[2], box2[2])\n    y2 = min(box1[3], box2[3])\n    \n    if x2 < x1 or y2 < y1:\n        return 0.0\n    \n    intersection = (x2 - x1) * (y2 - y1)\n    area1 = (box1[2] - box1[0]) * (box1[3] - box1[1])\n    area2 = (box2[2] - box2[0]) * (box2[3] - box2[1])\n    union = area1 + area2 - intersection\n    \n    return intersection / union if union > 0 else 0.0\n\ndef non_max_suppression(boxes, scores, iou_threshold=0.5):\n    \"\"\"éæå¤§å€¼æŠ‘åˆ¶ï¼ˆNMSï¼‰\"\"\"\n    if len(boxes) == 0:\n        return []\n    \n    # æŒ‰åˆ†æ•°æ’åº\n    indices = np.argsort(scores)[::-1]\n    keep = []\n    \n    while len(indices) > 0:\n        current = indices[0]\n        keep.append(current)\n        \n        if len(indices) == 1:\n            break\n        \n        # è®¡ç®—å½“å‰æ¡†ä¸å…¶ä»–æ¡†çš„IoU\n        current_box = boxes[current]\n        other_boxes = boxes[indices[1:]]\n        \n        ious = [calculate_iou(current_box, box) for box in other_boxes]\n        \n        # ç§»é™¤IoUå¤§äºé˜ˆå€¼çš„æ¡†\n        indices = indices[1:][np.array(ious) < iou_threshold]\n    \n    return keep\n\nclass YOLOLoss(nn.Module):\n    \"\"\"YOLOæŸå¤±å‡½æ•°\"\"\"\n    def __init__(self, S=7, B=2, C=20, lambda_coord=5.0, lambda_noobj=0.5):\n        super(YOLOLoss, self).__init__()\n        self.S = S  # ç½‘æ ¼å¤§å°\n        self.B = B  # æ¯ä¸ªç½‘æ ¼çš„è¾¹ç•Œæ¡†æ•°é‡\n        self.C = C  # ç±»åˆ«æ•°\n        self.lambda_coord = lambda_coord\n        self.lambda_noobj = lambda_noobj\n    \n    def forward(self, predictions, targets):\n        \"\"\"\n        predictions: [batch_size, S*S*(B*5+C)]\n        targets: [batch_size, S, S, B*5+C]\n        \"\"\"\n        batch_size = predictions.size(0)\n        predictions = predictions.view(batch_size, self.S, self.S, self.B * 5 + self.C)\n        \n        # åˆ†ç¦»é¢„æµ‹å€¼\n        pred_boxes = predictions[..., :self.B * 5].view(batch_size, self.S, self.S, self.B, 5)\n        pred_classes = predictions[..., self.B * 5:]\n        \n        # åˆ†ç¦»ç›®æ ‡å€¼\n        target_boxes = targets[..., :self.B * 5].view(batch_size, self.S, self.S, self.B, 5)\n        target_classes = targets[..., self.B * 5:]\n        \n        # è®¡ç®—åæ ‡æŸå¤±\n        coord_mask = target_boxes[..., 4:5] > 0  # æœ‰ç›®æ ‡çš„æ¡†\n        coord_loss = self.lambda_coord * torch.sum(\n            coord_mask * ((pred_boxes[..., :2] - target_boxes[..., :2]) ** 2 +\n                         (torch.sqrt(pred_boxes[..., 2:4]) - torch.sqrt(target_boxes[..., 2:4])) ** 2)\n        )\n        \n        # è®¡ç®—ç½®ä¿¡åº¦æŸå¤±\n        obj_mask = target_boxes[..., 4:5] > 0\n        noobj_mask = target_boxes[..., 4:5] == 0\n        \n        obj_loss = torch.sum(obj_mask * (pred_boxes[..., 4:5] - target_boxes[..., 4:5]) ** 2)\n        noobj_loss = self.lambda_noobj * torch.sum(\n            noobj_mask * (pred_boxes[..., 4:5] - target_boxes[..., 4:5]) ** 2\n        )\n        \n        # è®¡ç®—ç±»åˆ«æŸå¤±\n        class_loss = torch.sum(\n            obj_mask.squeeze(-1) * (pred_classes - target_classes) ** 2\n        )\n        \n        total_loss = coord_loss + obj_loss + noobj_loss + class_loss\n        return total_loss / batch_size\n\n# ä½¿ç”¨ç¤ºä¾‹\nif __name__ == \"__main__\":\n    # æµ‹è¯•IoUè®¡ç®—\n    box1 = [10, 10, 50, 50]\n    box2 = [30, 30, 70, 70]\n    iou = calculate_iou(box1, box2)\n    print(f\"IoU: {iou:.4f}\")\n    \n    # æµ‹è¯•YOLOæŸå¤±\n    S, B, C = 7, 2, 20\n    predictions = torch.randn(4, S * S * (B * 5 + C))\n    targets = torch.randn(4, S, S, B * 5 + C)\n    \n    criterion = YOLOLoss(S, B, C)\n    loss = criterion(predictions, targets)\n    print(f\"YOLO Loss: {loss.item():.4f}\")"
        }
      ]
    }
  ]
}