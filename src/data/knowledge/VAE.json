{
  "title": "VAE (Variational Autoencoder) å˜åˆ†è‡ªç¼–ç å™¨",
  "subtitle": "åŸºäºå˜åˆ†æ¨ç†çš„ç”Ÿæˆæ¨¡å‹",
  "content": [
    {
      "type": "section",
      "title": "ğŸ“– æ ¸å¿ƒæ¦‚å¿µ",
      "content": [
        {
          "type": "desc-box",
          "content": [
            "åŸºäºå˜åˆ†æ¨ç†çš„ç”Ÿæˆæ¨¡å‹ï¼Œå­¦ä¹ æ•°æ®çš„æ½œåœ¨è¡¨ç¤ºï¼ˆLatent Representationï¼‰ã€‚é€šè¿‡ç¼–ç å™¨å°†æ•°æ®æ˜ å°„åˆ°æ½œåœ¨ç©ºé—´çš„æ¦‚ç‡åˆ†å¸ƒï¼Œè§£ç å™¨ä»åˆ†å¸ƒä¸­é‡‡æ ·ç”Ÿæˆæ•°æ®ã€‚"
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸŒŸ æ ¸å¿ƒç‰¹ç‚¹",
      "content": [
        {
          "type": "features",
          "items": [
            "æ¦‚ç‡ç”Ÿæˆï¼šå­¦ä¹ æ½œåœ¨ç©ºé—´çš„æ¦‚ç‡åˆ†å¸ƒï¼Œè€Œéç¡®å®šæ€§æ˜ å°„",
            "ç¼–ç -è§£ç ï¼šEncoderå‹ç¼©æ•°æ®ï¼ŒDecoderé‡æ„æ•°æ®",
            "KLæ•£åº¦çº¦æŸï¼šæ­£åˆ™åŒ–æ½œåœ¨ç©ºé—´ï¼Œä½¿å…¶æ¥è¿‘æ ‡å‡†æ­£æ€åˆ†å¸ƒ",
            "è¿ç»­æ½œåœ¨ç©ºé—´ï¼šæ”¯æŒå¹³æ»‘æ’å€¼å’Œè¯­ä¹‰æ“ä½œ",
            "ç†è®ºå®Œå¤‡ï¼šæœ‰ä¸¥æ ¼çš„æ•°å­¦æ¨å¯¼ï¼ˆå˜åˆ†ä¸‹ç•ŒELBOï¼‰"
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "âš™ï¸ å…³é”®æŠ€æœ¯",
      "content": [
        {
          "type": "tech-box",
          "content": "é‡å‚æ•°åŒ–æŠ€å·§ï¼ˆReparameterization Trickï¼‰ã€ELBOæŸå¤±ã€KLæ•£åº¦"
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸš€ åº”ç”¨åœºæ™¯",
      "content": [
        {
          "type": "app-box",
          "content": "å›¾åƒç”Ÿæˆã€æ•°æ®å‹ç¼©ã€å¼‚å¸¸æ£€æµ‹ã€è¡¨ç¤ºå­¦ä¹ ã€Stable Diffusionçš„VAEç¼–ç å™¨"
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ“Š æ¶æ„å›¾è§£",
      "content": [
        {
          "type": "diagram-gallery",
          "images": [
            {
              "type": "svg-d3",
              "component": "VAEDiagram",
              "caption": "VAEæ¶æ„å›¾",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "VAEæ¶æ„å›¾",
                "data": null
              }
            },
            {
              "type": "svg-d3",
              "component": "VAEDiagram",
              "caption": "VAEæ½œåœ¨ç©ºé—´",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "VAEæ½œåœ¨ç©ºé—´",
                "data": null
              }
            },
            {
              "type": "svg-d3",
              "component": "VAEDiagram",
              "caption": "VAEè®­ç»ƒè¿‡ç¨‹",
              "width": 1000,
              "height": 800,
              "interactive": true,
              "props": {
                "type": "architecture",
                "title": "VAEè®­ç»ƒè¿‡ç¨‹",
                "data": null
              }
            }
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ“ æ•°å­¦åŸç†",
      "content": [
        {
          "type": "math-box",
          "title": "å˜åˆ†ä¸‹ç•Œï¼ˆELBOï¼‰",
          "formulas": [
            {
              "text": "VAE çš„ä¼˜åŒ–ç›®æ ‡æ˜¯æœ€å¤§åŒ–è¯æ®ä¸‹ç•Œï¼ˆELBOï¼‰ï¼š"
            },
            {
              "display": "\\log p(x) \\geq \\mathbb{E}_{z \\sim q_\\phi(z|x)}[\\log p_\\theta(x|z)] - D_{KL}(q_\\phi(z|x) || p(z))"
            },
            {
              "text": "å…¶ä¸­ï¼š"
            }
          ]
        },
        {
          "type": "math-box",
          "title": "é‡å‚æ•°åŒ–æŠ€å·§",
          "formulas": [
            {
              "text": "ä¸ºäº†å¯å¾®ï¼Œä½¿ç”¨é‡å‚æ•°åŒ–ï¼š"
            },
            {
              "display": "z = \\mu + \\sigma \\odot \\epsilon, \\quad \\epsilon \\sim \\mathcal{N}(0, I)"
            },
            {
              "text": "å…¶ä¸­ $\\mu$ å’Œ $\\sigma$ æ˜¯ç¼–ç å™¨è¾“å‡ºçš„å‡å€¼å’Œæ ‡å‡†å·®",
              "inline": "\\mu"
            }
          ]
        },
        {
          "type": "math-box",
          "title": "KLæ•£åº¦",
          "formulas": [
            {
              "text": "KLæ•£åº¦é¡¹ï¼ˆå‡è®¾å…ˆéªŒä¸ºæ ‡å‡†æ­£æ€åˆ†å¸ƒï¼‰ï¼š"
            },
            {
              "display": "D_{KL}(q_\\phi(z|x) || \\mathcal{N}(0, I)) = -\\frac{1}{2}\\sum_{i=1}^{d}(1 + \\log(\\sigma_i^2) - \\mu_i^2 - \\sigma_i^2)"
            },
            {
              "text": "å…¶ä¸­ $d$ æ˜¯æ½œåœ¨ç©ºé—´çš„ç»´åº¦",
              "inline": "d"
            }
          ]
        }
      ]
    },
    {
      "type": "section",
      "title": "ğŸ’» Python ä»£ç ç¤ºä¾‹",
      "content": [
        {
          "type": "code-box",
          "title": "ä½¿ç”¨ PyTorch å®ç° VAE",
          "language": "python",
          "code": "import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\n\nclass VAE(nn.Module):\n    \"\"\"å˜åˆ†è‡ªç¼–ç å™¨\"\"\"\n    def __init__(self, input_dim, hidden_dim, latent_dim):\n        super(VAE, self).__init__()\n        \n        # ç¼–ç å™¨\n        self.encoder = nn.Sequential(\n            nn.Linear(input_dim, hidden_dim),\n            nn.ReLU(),\n            nn.Linear(hidden_dim, hidden_dim),\n            nn.ReLU()\n        )\n        \n        # å‡å€¼å’Œæ–¹å·®\n        self.fc_mu = nn.Linear(hidden_dim, latent_dim)\n        self.fc_logvar = nn.Linear(hidden_dim, latent_dim)\n        \n        # è§£ç å™¨\n        self.decoder = nn.Sequential(\n            nn.Linear(latent_dim, hidden_dim),\n            nn.ReLU(),\n            nn.Linear(hidden_dim, hidden_dim),\n            nn.ReLU(),\n            nn.Linear(hidden_dim, input_dim),\n            nn.Sigmoid()\n        )\n    \n    def encode(self, x):\n        \"\"\"ç¼–ç \"\"\"\n        h = self.encoder(x)\n        mu = self.fc_mu(h)\n        logvar = self.fc_logvar(h)\n        return mu, logvar\n    \n    def reparameterize(self, mu, logvar):\n        \"\"\"é‡å‚æ•°åŒ–\"\"\"\n        std = torch.exp(0.5 * logvar)\n        eps = torch.randn_like(std)\n        return mu + eps * std\n    \n    def decode(self, z):\n        \"\"\"è§£ç \"\"\"\n        return self.decoder(z)\n    \n    def forward(self, x):\n        mu, logvar = self.encode(x)\n        z = self.reparameterize(mu, logvar)\n        recon_x = self.decode(z)\n        return recon_x, mu, logvar\n\ndef vae_loss(recon_x, x, mu, logvar, beta=1.0):\n    \"\"\"VAEæŸå¤±å‡½æ•°\"\"\"\n    # é‡æ„æŸå¤±\n    recon_loss = F.binary_cross_entropy(recon_x, x, reduction='sum')\n    \n    # KLæ•£åº¦æŸå¤±\n    kl_loss = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp())\n    \n    return recon_loss + beta * kl_loss, recon_loss, kl_loss\n\n# ä½¿ç”¨ç¤ºä¾‹\nif __name__ == \"__main__\":\n    input_dim = 784  # MNISTå›¾åƒå±•å¹³\n    hidden_dim = 400\n    latent_dim = 20\n    \n    model = VAE(input_dim, hidden_dim, latent_dim)\n    \n    # æ¨¡æ‹Ÿè¾“å…¥\n    x = torch.randn(32, input_dim)\n    \n    # å‰å‘ä¼ æ’­\n    recon_x, mu, logvar = model(x)\n    \n    # è®¡ç®—æŸå¤±\n    loss, recon_loss, kl_loss = vae_loss(recon_x, x, mu, logvar)\n    \n    print(f\"æ€»æŸå¤±: {loss.item():.4f}\")\n    print(f\"é‡æ„æŸå¤±: {recon_loss.item():.4f}\")\n    print(f\"KLæŸå¤±: {kl_loss.item():.4f}\")"
        }
      ]
    }
  ]
}